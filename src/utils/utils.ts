import React from 'react';

import {ContentTypes} from '@constants/Generic';
import ApplicationContextDataInterface from '@interfaces/ApplicationContextInterface';

/**
 * This method handles the form state changes for generic elements.
 * @param setState Set state action
 * @param key Key to set
 * @param value Value to set within key
 * @returns void
 */
export const handleFormStateChange = (setState: React.SetStateAction<Record<string, any>>, key: string, value?: any): void => {
    if (typeof setState == 'function') {
        setState((current: any) => {
            return {
                ...current,
                [key]: value
            };
        });
    }
}

/**
 * This method generates the endpoint URL for API calls.
 * @param baseUrl Base URL. Can be set but by default should be localhost
 * @param endpoint Endpoint to make a call to.
 * @returns 
 */
export const buildApiCallRoute = (baseUrl: string, endpoint: string): string => {
    return `http://${baseUrl}${endpoint}`;
}

/**
 * This method makes an API call
 * @param endpoint Endpoint to call to
 * @param method Method to use
 * @param csrfToken CSRF Token generated by Laravel backend.
 * @param headers Headers to set.
 * @param body Content that will be sent to the API.
 * @param onFail Method to call when the API call fails.
 * @returns 
 */
export const makeApiCall = async (appData: ApplicationContextDataInterface, endpointName: string, method: string, overrideHeaders: Record<string, any> = {}, body: any = {}): Promise<any> => {
    console.log('');
    try {
        const endpoint: string = buildApiCallRoute(appData.baseUrl, endpointName)
        console.log(`[Request call] Making API call to ${endpoint} (${method}): ${JSON.stringify(body)}`);
    
        const headers: Record<string, any> = getDefaultHeaders(appData);
        if (Object.keys(overrideHeaders).length) {
            Object.assign(headers, overrideHeaders);
        }

        console.log('[Request call] Request headers: ' + JSON.stringify(headers));

        if (method != 'GET') {
            body._method = method;
        }

        const requestOptions: Record<string, any> = {
            body: JSON.stringify(body),
            headers,
            method,
        };

        if (method == 'GET') {
            delete requestOptions?.body;
        }
    
        const response: Response = await fetch(endpoint, requestOptions);

        const text: string = await response.text();
        const logMessage: string = `Got ${response.status} from ${endpoint}: ${text}`;
    
        if (response.status != 200) {
            console.error('[Request call] ' + logMessage);
            return Promise.reject({response: response, statusCode: response.status});
        }

        console.info('[Request call] ' + logMessage);
    
        if (headers?.Accept == ContentTypes.JSON) {
            return Promise.resolve({response: JSON.parse(text), statusCode: response.status});
        }
        return Promise.resolve({response: text, statusCode: response.status});
    } catch (error) {
        console.error(error);
        return Promise.reject({error: error});
    }
}

/**
 * Default headers for the application in case none are set.
 */
export const getDefaultHeaders = (appData: ApplicationContextDataInterface): Record<string, any> => {
    const bearerToken: string|undefined = appData.userToken;
    const headers: Record<string, any> = {
        'Accept': ContentTypes.JSON,
        'Content-Type': ContentTypes.JSON,
        'X-CSRF-TOKEN': appData.csrfToken
    }
    if (bearerToken) {
        headers['Authorization'] = 'Bearer ' + appData.userToken;
    }
    return headers;
}